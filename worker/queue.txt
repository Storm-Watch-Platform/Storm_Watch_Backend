package worker

import (
	"container/heap"
	"sync"
)

// Job định nghĩa công việc
type Job struct {
	Priority int    // số càng cao → ưu tiên càng cao
	Exec     func() // hàm thực hiện
	index    int    // chỉ dùng trong heap
}

// JobHeap implement heap.Interface
type JobHeap []*Job

func (h JobHeap) Len() int { return len(h) }
func (h JobHeap) Less(i, j int) bool {
	// priority cao hơn chạy trước
	return h[i].Priority > h[j].Priority
}
func (h JobHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
	h[i].index = i
	h[j].index = j
}
func (h *JobHeap) Push(x any) {
	n := len(*h)
	job := x.(*Job)
	job.index = n
	*h = append(*h, job)
}
func (h *JobHeap) Pop() any {
	old := *h
	n := len(old)
	job := old[n-1]
	job.index = -1
	*h = old[0 : n-1]
	return job
}

// PriorityQueue thread-safe
type PriorityQueue struct {
	mu      sync.Mutex
	cond    *sync.Cond
	jobHeap JobHeap
}

// Khởi tạo PriorityQueue
func NewPriorityQueue() *PriorityQueue {
	pq := &PriorityQueue{}
	pq.cond = sync.NewCond(&pq.mu)
	heap.Init(&pq.jobHeap)
	return pq
}

// Push job vào queue
func (q *PriorityQueue) Push(job Job) {
	q.mu.Lock()
	defer q.mu.Unlock()
	heap.Push(&q.jobHeap, &job)
	q.cond.Signal() // báo worker nếu đang chờ
}

// Pop job (blocking nếu queue rỗng)
func (q *PriorityQueue) Pop() *Job {
	q.mu.Lock()
	defer q.mu.Unlock()

	for q.jobHeap.Len() == 0 {
		q.cond.Wait() // chờ có job
	}

	job := heap.Pop(&q.jobHeap).(*Job)
	return job
}

// Start worker loop
func (q *PriorityQueue) Start(workerCount int) {
	for i := 0; i < workerCount; i++ {
		go func() {
			for {
				job := q.Pop()
				if job != nil && job.Exec != nil {
					job.Exec()
				}
			}
		}()
	}
}
