package usecase

import (
	"context"
	"log"
	"time"

	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/domain" // generated by oapi-codegen
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/internal/ai"
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/internal/ws"
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/worker"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type ReportUseCase struct {
	queue   *worker.PriorityQueue
	aiQueue *worker.AIQueue
	ws      *ws.WSManager
	repo    domain.ReportRepository
	timeout time.Duration
	AI      *ai.Client

	zoneUC domain.ZoneUsecase
}

func NewReportUC(q *worker.PriorityQueue, aiq *worker.AIQueue, wsm *ws.WSManager, repo domain.ReportRepository, zoneUC domain.ZoneUsecase, timeout time.Duration) *ReportUseCase {
	aiClient, err := ai.New()
	if err != nil {
		log.Fatal("Failed to create ReportUseCase:", err)
	}

	return &ReportUseCase{
		queue:   q,
		aiQueue: aiq,
		ws:      wsm,
		repo:    repo,
		timeout: timeout,
		AI:      aiClient,
		zoneUC:  zoneUC,
	}
}

func convertUrgencyToRisk(urgency string) float64 {
	switch urgency {
	case "LOW":
		return 0.3
	case "MEDIUM":
		return 0.6
	case "HIGH":
		return 0.9
	default:
		return 0.2
	}
}

func (uc *ReportUseCase) Handle(client *ws.Client, r *domain.Report) error {
	r.UserID = client.UserID
	if r.Timestamp == 0 {
		r.Timestamp = time.Now().Unix()
	}

	// âœ… Náº¿u chÆ°a cÃ³ ID, táº¡o má»›i
	if r.ID.IsZero() {
		r.ID = primitive.NewObjectID()
	}

	// Step 1: save + broadcast in PriorityQueue
	uc.queue.Push(worker.Job{
		Priority: 2, // Report > Location
		Exec: func() {
			ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
			defer cancel()

			// Save report
			_ = uc.repo.Create(ctx, r)
			// uc.ws.BroadcastReport(client, r)
		},
	})

	// Step 2: AI analyze â€” run in separate AI queue
	uc.aiQueue.Push(func() {
		// Táº¡o context riÃªng cho AI
		ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
		defer cancel()

		// Ná»‘i cÃ¡c trÆ°á»ng lÃ m input cho AI
		inputText := r.Type + " " + r.Detail + " " + r.Description

		// print("AI INPUT TEXT: ", r.ID.Hex())
		// Gá»i AI client má»›i
		urgency, category, confidence, err := uc.AI.ClassifyHazardText(ctx, inputText)

		if err != nil {
			urgency = "MEDIUM"
			category = "OTHER"
			confidence = 0.0
		}

		// Táº¡o enrichment má»›i
		r.Enrichment = &domain.ReportEnrichment{
			Category:    category,
			Urgency:     urgency,
			Summary:     r.Detail,              // Hoáº·c AI summary náº¿u cÃ³
			Confidence:  int(confidence * 100), // float64 -> 0-100 int
			ExtractedAt: time.Now().Unix(),
		}

		// Update report trong DB vá»›i AI result
		if repoWithUpdate, ok := uc.repo.(interface {
			UpdateAI(ctx context.Context, reportID string, enrichment *domain.ReportEnrichment) error
		}); ok {
			_ = repoWithUpdate.UpdateAI(ctx, r.ID.Hex(), r.Enrichment)
		}

		// ğŸŸ©ğŸŸ©ğŸŸ© STEP 3 â€” UPDATE DANGER ZONE ğŸŸ©ğŸŸ©ğŸŸ©
		riskIncrement := convertUrgencyToRisk(urgency)

		lat := r.Location.Coordinates[1]
		lon := r.Location.Coordinates[0]

		// defaultRadius = 300m cháº³ng háº¡n
		_ = uc.zoneUC.AddRiskOrCreate(
			context.Background(),
			lat,
			lon,
			riskIncrement,
			3000.0,
		)
		// ğŸŸ©ğŸŸ©ğŸŸ© END STEP 3 ğŸŸ©ğŸŸ©ğŸŸ©

		// uc.ws.BroadcastAIResult(userID, r.Enrichment) // náº¿u cáº§n broadcast
		// Chuáº©n bá»‹ response gá»­i vá» client
		response := map[string]interface{}{
			"ok":     true,
			"report": r,
			"ai": map[string]interface{}{
				"urgency":       urgency,
				"incident_type": category,
				"confidence":    confidence,
			},
		}

		// Gá»­i trá»±c tiáº¿p cho client qua WS
		uc.ws.SendToClient(client, "report_created", response)

	})

	return nil
}

// Láº¥y report gáº§n
func (uc *ReportUseCase) GetNearbyReports(ctx context.Context, lat, lon, km float64) ([]*domain.Report, error) {
	return uc.repo.GetNearbyReports(ctx, lat, lon, km)
}
