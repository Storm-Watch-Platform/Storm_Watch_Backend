package ws

import (
	"sync"

	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/eventbus"
	"github.com/gorilla/websocket"
)

// Client đại diện 1 connection/tab
type Client struct {
	Conn         *websocket.Conn
	UserID       string
	IsBackground bool
	// subscribed targets (set of userID being followed)
	Subscriptions map[string]bool
}

// WSManager quản lý tất cả client & follow/subscription
type WSManager struct {
	mu sync.RWMutex

	// userID -> list of connections (all tabs)
	users map[string][]*Client

	// temp clients chưa CONNECT
	temp []*Client
}

// Khởi tạo WSManager
func NewWSManager() *WSManager {
	return &WSManager{
		users: make(map[string][]*Client),
		temp:  []*Client{},
	}
}

// tạm lưu client chưa CONNECT
func (m *WSManager) AddTempClient(c *Client) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.temp = append(m.temp, c)
}

// promote client sau CONNECT frame
func (m *WSManager) PromoteTempClient(c *Client) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// add to real user map
	m.users[c.UserID] = append(m.users[c.UserID], c)

	// remove from temp
	for i, t := range m.temp {
		if t == c {
			m.temp = append(m.temp[:i], m.temp[i+1:]...)
			break
		}
	}
}

// Remove client khi tab đóng hoặc lỗi
func (m *WSManager) RemoveClient(c *Client) {
	m.mu.Lock()
	defer m.mu.Unlock()

	// remove khỏi user map
	if list, ok := m.users[c.UserID]; ok {
		newList := []*Client{}
		for _, cc := range list {
			if cc != c {
				newList = append(newList, cc)
			}
		}
		if len(newList) == 0 {
			delete(m.users, c.UserID)
		} else {
			m.users[c.UserID] = newList
		}
	}

	// remove khỏi temp
	for i, t := range m.temp {
		if t == c {
			m.temp = append(m.temp[:i], m.temp[i+1:]...)
			break
		}
	}
}

// SUBSCRIBE target
func (m *WSManager) Subscribe(c *Client, targetUserID string) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if c.Subscriptions == nil {
		c.Subscriptions = make(map[string]bool)
	}

	c.Subscriptions[targetUserID] = true
}

// UNSUBSCRIBE target
func (m *WSManager) Unsubscribe(c *Client, targetUserID string) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if c.Subscriptions != nil {
		delete(c.Subscriptions, targetUserID)
	}
}

// B gửi vị trí → push tới tất cả client subscribe B
func (m *WSManager) SendLocationFromUser(targetUserID string, body string) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	for _, clients := range m.users {
		for _, c := range clients {
			if c.Subscriptions != nil && c.Subscriptions[targetUserID] {
				// gửi STOMP MESSAGE frame
				msg := "MESSAGE\n" +
					"content-type:application/json\n\n" +
					body + "\x00"

				c.Conn.WriteMessage(websocket.TextMessage, []byte(msg))
			}
		}
	}
}

// Lấy tất cả connection của user
func (m *WSManager) GetClients(userID string) []*Client {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.users[userID]
}

// WSManager.go
func (m *WSManager) HandleEvent(evt eventbus.Event) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	for _, clients := range m.users {
		for _, c := range clients {
			if c.Subscriptions != nil && c.Subscriptions[evt.User] {
				msg := "MESSAGE\ncontent-type:application/json\n\n" + evt.Body + "\x00"
				c.Conn.WriteMessage(websocket.TextMessage, []byte(msg))
			}
		}
	}
}
