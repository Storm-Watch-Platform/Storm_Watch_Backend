// ---------- worker/ai_queue.go ----------
package worker

import (
	"container/heap"
	"sync"
)

type AIJob struct {
	Priority int
	Exec     func()
	index    int
}

type AIJobHeap []*AIJob

func (h AIJobHeap) Len() int { return len(h) }
func (h AIJobHeap) Less(i, j int) bool {
	// Priority lớn chạy trước
	return h[i].Priority > h[j].Priority
}
func (h AIJobHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
	h[i].index = i
	h[j].index = j
}
func (h *AIJobHeap) Push(x any) { *h = append(*h, x.(*AIJob)) }
func (h *AIJobHeap) Pop() any {
	old := *h
	n := len(old)
	job := old[n-1]
	*h = old[:n-1]
	return job
}

type AIQueue struct {
	mu      sync.Mutex
	cond    *sync.Cond
	jobHeap AIJobHeap
}

func NewAIQueue() *AIQueue {
	q := &AIQueue{}
	q.cond = sync.NewCond(&q.mu)
	heap.Init(&q.jobHeap)
	return q
}

func (q *AIQueue) Push(job AIJob) {
	q.mu.Lock()
	defer q.mu.Unlock()
	heap.Push(&q.jobHeap, &job)
	q.cond.Signal()
}

func (q *AIQueue) Pop() *AIJob {
	q.mu.Lock()
	defer q.mu.Unlock()

	for q.jobHeap.Len() == 0 {
		q.cond.Wait()
	}

	return heap.Pop(&q.jobHeap).(*AIJob)
}

func (q *AIQueue) Start() {
	// Chỉ 1 worker vì AI nặng
	go func() {
		for {
			job := q.Pop()
			if job != nil && job.Exec != nil {
				job.Exec()
			}
		}
	}()
}
