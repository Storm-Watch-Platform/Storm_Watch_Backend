package usecase

import (
	"context"
	"log"
	"time"

	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/domain" // generated by oapi-codegen
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/internal/ai"
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/internal/ws"
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/worker"
)

type ReportUseCase struct {
	queue   *worker.PriorityQueue
	aiQueue *worker.AIQueue
	ws      *ws.WSManager
	repo    domain.ReportRepository
	timeout time.Duration
	AI      *ai.Client
}

func NewReportUC(q *worker.PriorityQueue, aiq *worker.AIQueue, wsm *ws.WSManager, repo domain.ReportRepository, timeout time.Duration) *ReportUseCase {
	aiClient, err := ai.New()
	if err != nil {
		log.Fatal("Failed to create ReportUseCase:", err)
	}

	return &ReportUseCase{
		queue:   q,
		aiQueue: aiq,
		ws:      wsm,
		repo:    repo,
		timeout: timeout,
		AI:      aiClient,
	}
}

func (uc *ReportUseCase) Handle(client *ws.Client, r *domain.Report) error {
	r.UserID = client.UserID
	r.Timestamp = time.Now().Unix() // giống Location

	// Step 1: save + broadcast in PriorityQueue
	uc.queue.Push(worker.Job{
		Priority: 2, // Report > Location
		Exec: func() {
			ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
			defer cancel()

			// Save report
			_ = uc.repo.Create(ctx, r)
			// uc.ws.BroadcastReport(client, r)
		},
	})

	// Step 2: AI analyze — run in separate AI queue
	uc.aiQueue.Push(func() {
		// Tạo context riêng cho AI
		ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
		defer cancel()

		// Nối các trường làm input cho AI
		inputText := r.Type + " " + r.Detail + " " + r.Description

		// Gọi AI client mới
		urgency, category, confidence, err := uc.AI.ClassifyHazardText(ctx, inputText)

		if err != nil {
			urgency = "MEDIUM"
			category = "OTHER"
			confidence = 0.0
		}

		// Tạo enrichment mới
		r.Enrichment = &domain.ReportEnrichment{
			Category:    category,
			Urgency:     urgency,
			Summary:     r.Detail,              // Hoặc AI summary nếu có
			Confidence:  int(confidence * 100), // float64 -> 0-100 int
			ExtractedAt: time.Now().Unix(),
		}

		// Update report trong DB với AI result
		if repoWithUpdate, ok := uc.repo.(interface {
			UpdateAI(ctx context.Context, reportID string, enrichment *domain.ReportEnrichment) error
		}); ok {
			_ = repoWithUpdate.UpdateAI(ctx, r.ID.Hex(), r.Enrichment)
		}

		// uc.ws.BroadcastAIResult(userID, r.Enrichment) // nếu cần broadcast
		// Chuẩn bị response gửi về client
		response := map[string]interface{}{
			"ok":     true,
			"report": r,
			"ai": map[string]interface{}{
				"urgency":       urgency,
				"incident_type": category,
				"confidence":    confidence,
			},
		}

		// Gửi trực tiếp cho client qua WS
		uc.ws.SendToClient(client, "report_created", response)

	})

	return nil
}

// Lấy report gần
func (uc *ReportUseCase) GetNearbyReports(ctx context.Context, lat, lon, km float64) ([]*domain.Report, error) {
	return uc.repo.GetNearbyReports(ctx, lat, lon, km)
}
