package usecase

import (
	"context"
	"log"
	"time"

	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/domain" // generated by oapi-codegen
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/internal/ai"
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/internal/ws"
	"github.com/Storm-Watch-Platform/Storm_Watch_Backend/worker"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

type ReportUseCase struct {
	queue   *worker.PriorityQueue
	aiQueue *worker.AIQueue
	ws      *ws.WSManager
	repo    domain.ReportRepository
	timeout time.Duration
	AI      *ai.Client

	zoneUC domain.ZoneUsecase
}

func NewReportUC(q *worker.PriorityQueue, aiq *worker.AIQueue, wsm *ws.WSManager, repo domain.ReportRepository, zoneUC domain.ZoneUsecase, timeout time.Duration) *ReportUseCase {
	aiClient, err := ai.New()
	if err != nil {
		log.Fatal("Failed to create ReportUseCase:", err)
	}

	return &ReportUseCase{
		queue:   q,
		aiQueue: aiq,
		ws:      wsm,
		repo:    repo,
		timeout: timeout,
		AI:      aiClient,
		zoneUC:  zoneUC,
	}
}

func convertUrgencyToRisk(urgency string) float64 {
	switch urgency {
	case "LOW":
		return 0.3
	case "MEDIUM":
		return 0.6
	case "HIGH":
		return 0.9
	default:
		return 0.2
	}
}

// func (uc *ReportUseCase) Handle(client *ws.Client, r *domain.Report) error {
// 	r.UserID = client.UserID
// 	if r.Timestamp == 0 {
// 		r.Timestamp = time.Now().Unix()
// 	}

// 	// ‚úÖ N·∫øu ch∆∞a c√≥ ID, t·∫°o m·ªõi
// 	if r.ID.IsZero() {
// 		r.ID = primitive.NewObjectID()
// 	}

// 	// Step 1: save + broadcast in PriorityQueue
// 	uc.queue.Push(worker.Job{
// 		Priority: 2, // Report > Location
// 		Exec: func() {
// 			ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
// 			defer cancel()

// 			// Save report
// 			_ = uc.repo.Create(ctx, r)
// 			// uc.ws.BroadcastReport(client, r)
// 		},
// 	})

// 	// Step 2: AI analyze ‚Äî run in separate AI queue
// 	uc.aiQueue.Push(func() {
// 		// T·∫°o context ri√™ng cho AI
// 		ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
// 		defer cancel()

// 		// N·ªëi c√°c tr∆∞·ªùng l√†m input cho AI
// 		inputText := r.Type + " " + r.Detail + " " + r.Description

// 		// print("AI INPUT TEXT: ", r.ID.Hex())
// 		// G·ªçi AI client m·ªõi
// 		urgency, category, confidence, err := uc.AI.ClassifyHazardText(ctx, inputText)

// 		if err != nil {
// 			urgency = "MEDIUM"
// 			category = "OTHER"
// 			confidence = 0.0
// 		}

// 		// T·∫°o enrichment m·ªõi
// 		r.Enrichment = &domain.ReportEnrichment{
// 			Category:    category,
// 			Urgency:     urgency,
// 			Summary:     r.Detail,              // Ho·∫∑c AI summary n·∫øu c√≥
// 			Confidence:  int(confidence * 100), // float64 -> 0-100 int
// 			ExtractedAt: time.Now().Unix(),
// 		}

// 		// Update report trong DB v·ªõi AI result
// 		if repoWithUpdate, ok := uc.repo.(interface {
// 			UpdateAI(ctx context.Context, reportID string, enrichment *domain.ReportEnrichment) error
// 		}); ok {
// 			_ = repoWithUpdate.UpdateAI(ctx, r.ID.Hex(), r.Enrichment)
// 		}

// 		// üü©üü©üü© STEP 3 ‚Äî UPDATE DANGER ZONE üü©üü©üü©
// 		riskIncrement := convertUrgencyToRisk(urgency)

// 		lat := r.Location.Coordinates[1]
// 		lon := r.Location.Coordinates[0]

// 		// defaultRadius = 300m ch·∫≥ng h·∫°n
// 		_ = uc.zoneUC.AddRiskOrCreate(
// 			context.Background(),
// 			lat,
// 			lon,
// 			riskIncrement,
// 			3000.0,
// 		)
// 		// üü©üü©üü© END STEP 3 üü©üü©üü©

// 		// uc.ws.BroadcastAIResult(userID, r.Enrichment) // n·∫øu c·∫ßn broadcast
// 		// Chu·∫©n b·ªã response g·ª≠i v·ªÅ client
// 		response := map[string]interface{}{
// 			"ok":     true,
// 			"report": r,
// 			"ai": map[string]interface{}{
// 				"urgency":       urgency,
// 				"incident_type": category,
// 				"confidence":    confidence,
// 			},
// 		}

// 		// G·ª≠i tr·ª±c ti·∫øp cho client qua WS
// 		uc.ws.SendToClient(client, "report_created", response)

// 	})

// 	return nil
// }

func (uc *ReportUseCase) Handle(client *ws.Client, r *domain.Report) error {
	r.UserID = client.UserID
	if r.Timestamp == 0 {
		r.Timestamp = time.Now().Unix()
	}

	if r.ID.IsZero() {
		r.ID = primitive.NewObjectID()
	}

	// STEP 1 ‚Äî Save report
	uc.queue.Push(worker.Job{
		Priority: 2,
		Exec: func() {
			ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
			defer cancel()

			if err := uc.repo.Create(ctx, r); err != nil {
				uc.ws.SendToClient(client, "report_created", map[string]interface{}{
					"ok":    false,
					"error": "Failed to save report: " + err.Error(),
				})
				return
			}
		},
	})

	// STEP 2 ‚Äî AI analyze
	uc.aiQueue.Push(func() {
		ctx, cancel := context.WithTimeout(context.Background(), uc.timeout)
		defer cancel()

		inputText := r.Type + " " + r.Detail + " " + r.Description

		urgency, category, confidence, err := uc.AI.ClassifyHazardText(ctx, inputText)
		if err != nil {
			// Fallback nh∆∞ default
			urgency = "MEDIUM"
			category = "OTHER"
			confidence = 0.0
		}

		// Build enrichment
		r.Enrichment = &domain.ReportEnrichment{
			Category:    category,
			Urgency:     urgency,
			Summary:     r.Detail,
			Confidence:  int(confidence * 100),
			ExtractedAt: time.Now().Unix(),
		}

		// UpdateAI
		if repoWithUpdate, ok := uc.repo.(interface {
			UpdateAI(ctx context.Context, reportID string, enrichment *domain.ReportEnrichment) error
		}); ok {
			if err := repoWithUpdate.UpdateAI(ctx, r.ID.Hex(), r.Enrichment); err != nil {
				uc.ws.SendToClient(client, "report_created", map[string]interface{}{
					"ok":    false,
					"error": "Failed to update AI enrichment: " + err.Error(),
				})
				return
			}
		}

		// STEP 3 ‚Äî Update danger zone
		riskIncrement := convertUrgencyToRisk(urgency)

		lat := r.Location.Coordinates[1]
		lon := r.Location.Coordinates[0]

		if err := uc.zoneUC.AddRiskOrCreate(
			context.Background(),
			lat,
			lon,
			riskIncrement,
			3000.0,
		); err != nil {

			uc.ws.SendToClient(client, "report_created", map[string]interface{}{
				"ok":    false,
				"error": "Failed to update danger zone: " + err.Error(),
			})
			return
		}

		// SUCCESS RESPONSE
		uc.ws.SendToClient(client, "report_created", map[string]interface{}{
			"ok":     true,
			"report": r,
			"ai": map[string]interface{}{
				"urgency":       urgency,
				"incident_type": category,
				"confidence":    confidence,
			},
		})
	})

	return nil
}

// L·∫•y report g·∫ßn
func (uc *ReportUseCase) GetNearbyReports(ctx context.Context, lat, lon, km float64) ([]*domain.Report, error) {
	return uc.repo.GetNearbyReports(ctx, lat, lon, km)
}
